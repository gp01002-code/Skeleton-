<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D人體骨骼拼圖 V1.0</title>
    <!-- 引入 Tailwind CSS 以進行快速樣式設計 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自訂樣式 */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c; /* 深色背景 */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 320px;
            z-index: 10; /* 確保在VR按鈕之上 */
        }
        .bone-name {
            min-height: 32px; /* 預留空間避免跳動 */
        }
        .button {
            transition: all 0.2s ease-in-out;
        }
        .button:hover {
            transform: scale(1.05);
        }
        #completion-message {
            display: none; /* 預設隱藏 */
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <!-- 讀取指示器 -->
    <div id="loading-overlay" class="absolute inset-0 z-30 flex items-center justify-center bg-black bg-opacity-70 text-white">
        <p class="text-2xl">模型載入中...</p>
    </div>

    <!-- 遊戲資訊面板 -->
    <div id="info-panel-html" class="info-panel shadow-lg">
        <h1 class="text-2xl font-bold text-white">3D人體骨骼拼圖</h1>
        <p id="instruction-text" class="text-gray-300 mt-1">將骨骼拖曳到中央骨架的正確位置上。</p>
        <p id="bone-name-text" class="mt-3 text-xl text-cyan-300 font-semibold bone-name"></p>
        <!-- 新增：計時器顯示 -->
        <p id="timer-text" class="mt-2 text-2xl text-yellow-300 font-mono">時間: 00:00</p>
    </div>

    <!-- 遊戲完成訊息 -->
    <div id="completion-message" class="absolute inset-0 z-20 flex-col items-center justify-center bg-black bg-opacity-80 text-white text-center">
        <h2 class="text-6xl font-bold mb-4 animate-pulse">恭喜！</h2>
        <p class="text-2xl mb-8">您已成功拼湊出完整的人體骨骼！</p>
        <button id="play-again-button" class="bg-blue-600 hover-bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl button shadow-xl">
            再玩一次
        </button>
    </div>

    <!-- 重置按鈕 -->
    <button id="reset-button" class="absolute bottom-5 right-5 bg-red-600 hover-bg-red-700 text-white font-bold py-2 px-5 rounded-lg z-10 button shadow-lg">
        重置
    </button>

    <!-- Three.js ES6 模組引入 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- 主要遊戲邏輯 -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- 變數初始化 ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let selectedObject = null;
        let controller1, controller2;
        let gameGroup;
        
        const draggableObjects = [];
        const bonesData = [];
        let modelsToLoad = 0;

        // 新增：計時器變數
        let startTime = null;
        let timerInterval = null;
        let vrInfoPanel; // VR 資訊面板

        // UI 元素
        const boneNameText = document.getElementById('bone-name-text');
        const timerText = document.getElementById('timer-text');
        const completionMessage = document.getElementById('completion-message');
        const resetButton = document.getElementById('reset-button');
        const playAgainButton = document.getElementById('play-again-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const infoPanelHTML = document.getElementById('info-panel-html');
        
        const sceneScaleFactor = 10;
        const referencePosition = new THREE.Vector3(0, 15.5, 0);

        const boneDefinitions = [
            { id: 'pelvis', name: '骨盆', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/pelvis.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, 0, 0), targetPos: new THREE.Vector3(0, 16, 0) },
            { id: 'spinal_cord', name: '脊柱', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/spinal%20cord.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(0, -80, 0), targetPos: new THREE.Vector3(0, 36.5, -2) },
            { id: 'chest', name: '胸腔', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/chest.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(0, 80, 0), targetPos: new THREE.Vector3(0, 44, 0) },
            { id: 'skull', name: '頭骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/head.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, 50, 0), targetPos: new THREE.Vector3(0, 70.5, -1) },
            { id: 'humerus_l', name: '左肱骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/upperarm02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-95, 30, 0), targetPos: new THREE.Vector3(-11, 43.5, 0) },
            { id: 'humerus_r', name: '右肱骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/upperarm.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(95, 30, 0), targetPos: new THREE.Vector3(11, 43.5, 0) },
            { id: 'radius_ulna_l', name: '左前臂骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/forearm02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-95, -20, 0), targetPos: new THREE.Vector3(-22, 15, 0) },
            { id: 'radius_ulna_r', name: '右前臂骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/forearm.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(95, -20, 0), targetPos: new THREE.Vector3(22, 15, 0) },
            { id: 'femur_l', name: '左股骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/thighbone02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, -50, 0), targetPos: new THREE.Vector3(-8, 0.5, 0) },
            { id: 'femur_r', name: '右股骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/thighbone.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, -50, 0), targetPos: new THREE.Vector3(8, 0.5, 0) },
            { id: 'tibia_l', name: '左脛骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/calf%20bone%2002.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, -80, 0), targetPos: new THREE.Vector3(-6, -34.5, 0) },
            { id: 'tibia_r', name: '右脛骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/calf%20bone.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, -80, 0), targetPos: new THREE.Vector3(6, -34.5, 0) }
        ];
        
        init();

        function init() {
            scene = new THREE.Scene();
            gameGroup = new THREE.Group();
            scene.add(gameGroup);

            new THREE.TextureLoader().load(
                'https://live.staticflickr.com/65535/49333912182_a231368962_k.jpg',
                (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.background = texture;
                    scene.environment = texture;
                }
            );

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 250;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(50, 100, 75);
            scene.add(directionalLight);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            createVRInfoPanel();
            setupVRControllers();
            loadFullSkeletonReference();
            createBones();

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
            renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: false });
            renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onPointerUp);
            
            resetButton.addEventListener('click', resetGame);
            playAgainButton.addEventListener('click', resetGame);
            
            renderer.setAnimationLoop(animate);
            
            // 新增：監聽VR session事件來切換UI
            renderer.xr.addEventListener('sessionstart', () => {
                infoPanelHTML.style.display = 'none';
                vrInfoPanel.visible = true;
            });
            renderer.xr.addEventListener('sessionend', () => {
                infoPanelHTML.style.display = 'block';
                vrInfoPanel.visible = false;
            });
        }

        function createVRInfoPanel() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const canvasWidth = 512;
            const canvasHeight = 256;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const geometry = new THREE.PlaneGeometry(50, 25);
            vrInfoPanel = new THREE.Mesh(geometry, material);
            vrInfoPanel.position.set(0, 60, -100); // 放在玩家面前
            vrInfoPanel.visible = false; // 預設隱藏
            scene.add(vrInfoPanel);

            vrInfoPanel.userData.context = context;
            vrInfoPanel.userData.texture = texture;
            updateVRInfoPanel(" ", "時間: 00:00"); // 初始畫面
        }

        function updateVRInfoPanel(boneText, timeText) {
            if (!vrInfoPanel) return;
            const context = vrInfoPanel.userData.context;
            const texture = vrInfoPanel.userData.texture;

            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, context.canvas.width, context.canvas.height);
            
            context.fillStyle = 'white';
            context.font = '30px sans-serif';
            context.fillText('3D人體骨骼拼圖', 20, 50);

            context.fillStyle = '#00ffff'; // cyan
            context.font = 'bold 36px sans-serif';
            context.fillText(boneText, 20, 120);

            context.fillStyle = '#ffff00'; // yellow
            context.font = '40px sans-serif';
            context.fillText(timeText, 20, 200);

            texture.needsUpdate = true;
        }

        function setupVRControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            scene.add(controller2);

            const lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
            const line = new THREE.Line(lineGeometry);
            line.scale.z = 100;
            controller1.add(line.clone());
            controller2.add(line.clone());
        }

        function onSelectStart(event) {
            if (!startTime) startTimer();
            const controller = event.target;
            const intersections = getIntersections(controller);

            if (intersections.length > 0) {
                let object = intersections[0].object;
                while (object.parent && !object.userData.type) {
                    object = object.parent;
                }
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    selectedObject = object;
                    controller.attach(selectedObject);
                }
            }
        }

        function onSelectEnd(event) {
            if (selectedObject) {
                gameGroup.attach(selectedObject);
                const targetPos = selectedObject.userData.targetPos;
                const distance = selectedObject.position.distanceTo(targetPos);
                if (distance < 40) {
                    selectedObject.position.copy(targetPos);
                    selectedObject.userData.placed = true;
                    selectedObject.material.color.set(0x50c878);
                    checkCompletion();
                } else {
                    selectedObject.position.copy(selectedObject.userData.initialPos);
                }
                selectedObject = null;
            }
        }

        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            return raycaster.intersectObjects(draggableObjects, true);
        }
        
        function modelLoaded() {
            modelsToLoad--;
            if (modelsToLoad <= 0) {
                loadingOverlay.style.display = 'none';
            }
        }

        function loadFullSkeletonReference() {
            modelsToLoad++;
            const loader = new STLLoader();
            const modelUrl = 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/untitled.stl';
            
            loader.load(modelUrl, (geometry) => {
                const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.25 });
                geometry.computeBoundingBox();
                const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                geometry.translate(-center.x, -center.y, -center.z);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(0.35 * sceneScaleFactor, 0.35 * sceneScaleFactor, 0.35 * sceneScaleFactor);
                mesh.position.copy(referencePosition); 
                mesh.rotation.x = -Math.PI / 2;
                gameGroup.add(mesh);
                modelLoaded();
            }, undefined, (error) => {
                console.error('無法載入完整骨架參考模型', error);
                modelLoaded();
            });
        }
        
        function createBones() {
            const stlLoader = new STLLoader();
            boneDefinitions.forEach(def => {
                modelsToLoad++;
                const url = def.modelUrl.replace(/ /g, '%20');
                stlLoader.load(url, (geometry) => {
                    const material = new THREE.MeshStandardMaterial({ color: 0xebe5d1 });
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    geometry.translate(-center.x, -center.y, -center.z);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.scale.set(def.scale, def.scale, def.scale);
                    mesh.rotation.x = -Math.PI / 2;
                    setupBone(mesh, def);
                    modelLoaded();
                }, undefined, (error) => {
                    console.error(`無法載入模型: ${def.id}`, error);
                    modelLoaded();
                });
            });
        }

        function setupBone(mesh, def) {
            mesh.position.copy(def.initialPos);
            mesh.userData = { 
                id: def.id, 
                name: def.name, 
                type: 'draggable', 
                placed: false, 
                initialPos: def.initialPos.clone(),
                targetPos: def.targetPos
            };
            gameGroup.add(mesh);
            draggableObjects.push(mesh);
            bonesData.push(mesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePointerPosition(event) {
            const pointer = event.touches ? event.touches[0] : event;
            mouse.x = (pointer.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(pointer.clientY / window.innerHeight) * 2 + 1;
        }

        function onPointerDown(event) {
            if (event.touches) event.preventDefault();
            if (!startTime) startTimer();
            updatePointerPosition(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggableObjects, true);

            if (intersects.length > 0) {
                let object = intersects[0].object;
                 while (object.parent && !object.userData.type) {
                    object = object.parent;
                }
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    selectedObject = object;
                    controls.enabled = false;
                }
            }
        }

        function onPointerMove(event) {
            if (event.touches) event.preventDefault();
            updatePointerPosition(event);

            let currentBoneName = "";
            let currentTimeText = timerText.textContent;

            if (selectedObject) {
                const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                selectedObject.position.copy(pos);
            } else {
                 raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(draggableObjects, true);
                if (intersects.length > 0) {
                    let object = intersects[0].object;
                     while (object.parent && !object.userData.type) {
                        object = object.parent;
                    }
                    if (object.userData.name) {
                       currentBoneName = object.userData.name;
                    }
                }
            }
            boneNameText.textContent = currentBoneName;
            updateVRInfoPanel(currentBoneName, currentTimeText);
        }

        function onPointerUp(event) {
            if (selectedObject) {
                const targetPos = selectedObject.userData.targetPos;
                const distance = selectedObject.position.distanceTo(targetPos);
                if (distance < 40) {
                    selectedObject.position.copy(targetPos);
                    selectedObject.userData.placed = true;
                    selectedObject.material.color.set(0x50c878);
                    checkCompletion();
                } else {
                    selectedObject.position.copy(selectedObject.userData.initialPos);
                }
            }
            selectedObject = null;
            controls.enabled = true;
        }

        function checkCompletion() {
            const allPlaced = draggableObjects.every(obj => obj.userData.placed);
            if (allPlaced) {
                stopTimer();
                completionMessage.style.display = 'flex';
            }
        }

        // --- 計時器功能 ---
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 1000);
        }
        function stopTimer() {
            clearInterval(timerInterval);
        }
        function resetTimer() {
            stopTimer();
            startTime = null;
            timerText.textContent = "時間: 00:00";
            updateVRInfoPanel(boneNameText.textContent, "時間: 00:00");
        }
        function updateTimerDisplay() {
            if (!startTime) return;
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
            const seconds = (elapsedTime % 60).toString().padStart(2, '0');
            const timeString = `時間: ${minutes}:${seconds}`;
            timerText.textContent = timeString;
            updateVRInfoPanel(boneNameText.textContent, timeString);
        }

        function resetGame() {
            completionMessage.style.display = 'none';
            resetTimer();
            bonesData.forEach(bone => {
                bone.userData.placed = false;
                bone.position.copy(bone.userData.initialPos);
                bone.material.color.set(0xebe5d1);
            });
        }
        
        function animate() {
            controls.update();
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>

