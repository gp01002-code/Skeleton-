<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D人體骨骼拼圖 V2.0 (操作優化版)</title>
    <!-- 引入 Tailwind CSS 以進行快速樣式設計 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自訂樣式 */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c; /* 深色背景 */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 320px;
            z-index: 10; /* 確保在VR按鈕之上 */
        }
        .bone-name {
            min-height: 32px; /* 預留空間避免跳動 */
        }
        .button {
            transition: all 0.2s ease-in-out;
        }
        .button:hover {
            transform: scale(1.05);
        }
        #completion-message {
            display: none; /* 預設隱藏 */
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <!-- 讀取指示器 -->
    <div id="loading-overlay" class="absolute inset-0 z-30 flex items-center justify-center bg-black bg-opacity-70 text-white">
        <p class="text-2xl">模型載入中...</p>
    </div>

    <!-- 遊戲資訊面板 -->
    <div class="info-panel shadow-lg">
        <h1 class="text-2xl font-bold text-white">3D人體骨骼拼圖</h1>
        <p id="instruction-text" class="text-gray-300 mt-1">將骨骼拖曳到中央骨架的正確位置上。</p>
        <p id="bone-name-text" class="mt-3 text-xl text-cyan-300 font-semibold bone-name"></p>
    </div>

    <!-- 遊戲完成訊息 -->
    <div id="completion-message" class="absolute inset-0 z-20 flex-col items-center justify-center bg-black bg-opacity-80 text-white text-center">
        <h2 class="text-6xl font-bold mb-4 animate-pulse">恭喜！</h2>
        <p class="text-2xl mb-8">您已成功拼湊出完整的人體骨骼！</p>
        <button id="play-again-button" class="bg-blue-600 hover-bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl button shadow-xl">
            再玩一次
        </button>
    </div>

    <!-- 重置按鈕 -->
    <button id="reset-button" class="absolute bottom-5 right-5 bg-red-600 hover-bg-red-700 text-white font-bold py-2 px-5 rounded-lg z-10 button shadow-lg">
        重置
    </button>

    <!-- Three.js ES6 模組引入 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- 主要遊戲邏輯 -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- 變數初始化 ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let selectedObject = null;
        let controller1, controller2; // VR 控制器
        let controllerGrip1, controllerGrip2;
        let gameGroup; // 用於容納所有遊戲物件的群組
        
        // --- 操作優化變數 ---
        const dragPlane = new THREE.Plane();
        const intersectionPoint = new THREE.Vector3();
        let longPressTimeout = null;
        let isDragging = false;
        const pointerDownPosition = new THREE.Vector2();


        const draggableObjects = [];
        const bonesData = [];
        let modelsToLoad = 0;

        // UI 元素
        const boneNameText = document.getElementById('bone-name-text');
        const completionMessage = document.getElementById('completion-message');
        const resetButton = document.getElementById('reset-button');
        const playAgainButton = document.getElementById('play-again-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        
        const sceneScaleFactor = 10;
        const referencePosition = new THREE.Vector3(0, 15.5, 0);

        // --- 骨骼資料定義 ---
        const boneDefinitions = [
            { id: 'pelvis', name: '骨盆', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/pelvis.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, 0, 0), targetPos: new THREE.Vector3(0, 16, 0) },
            { id: 'spinal_cord', name: '脊柱', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/spinal%20cord.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(0, -80, 0), targetPos: new THREE.Vector3(0, 36.5, -2) },
            { id: 'chest', name: '胸腔', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/chest.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(0, 80, 0), targetPos: new THREE.Vector3(0, 44, 0) },
            { id: 'skull', name: '頭骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/head.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, 50, 0), targetPos: new THREE.Vector3(0, 70.5, -1) },
            { id: 'humerus_l', name: '左肱骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/upperarm02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-95, 30, 0), targetPos: new THREE.Vector3(-11, 43.5, 0) },
            { id: 'humerus_r', name: '右肱骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/upperarm.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(95, 30, 0), targetPos: new THREE.Vector3(11, 43.5, 0) },
            { id: 'radius_ulna_l', name: '左前臂骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/forearm02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-95, -20, 0), targetPos: new THREE.Vector3(-22, 15, 0) },
            { id: 'radius_ulna_r', name: '右前臂骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/forearm.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(95, -20, 0), targetPos: new THREE.Vector3(22, 15, 0) },
            { id: 'femur_l', name: '左股骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/thighbone02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, -50, 0), targetPos: new THREE.Vector3(-8, 0.5, 0) },
            { id: 'femur_r', name: '右股骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/thighbone.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, -50, 0), targetPos: new THREE.Vector3(8, 0.5, 0) },
            { id: 'tibia_l', name: '左脛骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/calf%20bone%2002.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, -80, 0), targetPos: new THREE.Vector3(-6, -34.5, 0) },
            { id: 'tibia_r', name: '右脛骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/calf%20bone.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, -80, 0), targetPos: new THREE.Vector3(6, -34.5, 0) }
        ];
        
        init();

        function init() {
            scene = new THREE.Scene();
            
            gameGroup = new THREE.Group();
            gameGroup.position.z = -80; 
            scene.add(gameGroup);

            new THREE.TextureLoader().load(
                'https://live.staticflickr.com/65535/49333912182_a231368962_k.jpg',
                (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.background = texture;
                    scene.environment = texture;
                }
            );

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 220;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(50, 100, 75);
            scene.add(directionalLight);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            // 優化：讓鏡頭圍繞骨架中心旋轉，而不是世界中心
            controls.target.copy(referencePosition).add(gameGroup.position);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            setupVRControllers();
            loadFullSkeletonReference();
            createBones();

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
            renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: false });
            renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onPointerUp);
            
            resetButton.addEventListener('click', resetGame);
            playAgainButton.addEventListener('click', resetGame);
            
            renderer.setAnimationLoop(animate);
        }

        function setupVRControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            scene.add(controller2);

            const controllerModelFactory = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
            );

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.clone());
            scene.add(controllerGrip1);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.clone());
            scene.add(controllerGrip2);
        }

        function onSelectStart(event) {
            const controller = event.target;
            const intersections = getIntersections(controller);

            if (intersections.length > 0) {
                let object = intersections[0].object;
                while (object.parent && !object.userData.type) {
                    object = object.parent;
                }
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    selectedObject = object;
                    controller.attach(selectedObject);
                }
            }
        }

        function onSelectEnd(event) {
            if (selectedObject) {
                gameGroup.attach(selectedObject);
                
                const targetPos = selectedObject.userData.targetPos;
                const distance = selectedObject.position.distanceTo(targetPos);

                if (distance < 40) { // VR吸附範圍
                    selectedObject.position.copy(targetPos);
                    selectedObject.userData.placed = true;
                    selectedObject.material.color.set(0x50c878);
                    checkCompletion();
                } else {
                    selectedObject.position.copy(selectedObject.userData.initialPos);
                }
                selectedObject = null;
            }
        }
        
        // 優化：VR控制器的視覺回饋
        function handleController(controller) {
            if (controller.visible) {
                const intersections = getIntersections(controller);
                const line = controller.getObjectByProperty('type', 'Line');
                
                if (intersections.length > 0) {
                     let object = intersections[0].object;
                     while (object.parent && !object.userData.type) {
                        object = object.parent;
                     }
                    if(object.userData.type === 'draggable' && !object.userData.placed){
                        line.material.color.set(0x00ff00); // 綠色表示可選取
                    } else {
                        line.material.color.set(0xffffff); // 白色
                    }
                } else {
                    line.material.color.set(0xffffff); // 白色
                }
            }
        }


        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            return raycaster.intersectObjects(draggableObjects, true);
        }
        
        function modelLoaded() {
            modelsToLoad--;
            if (modelsToLoad <= 0) {
                loadingOverlay.style.display = 'none';
            }
        }

        function loadFullSkeletonReference() {
            modelsToLoad++;
            const loader = new STLLoader();
            const modelUrl = 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/untitled.stl';
            
            loader.load(modelUrl, (geometry) => {
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.25,
                    metalness: 0.2,
                    roughness: 0.8
                });
                geometry.computeBoundingBox();
                const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                geometry.translate(-center.x, -center.y, -center.z);

                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(0.35 * sceneScaleFactor, 0.35 * sceneScaleFactor, 0.35 * sceneScaleFactor);
                mesh.position.copy(referencePosition); 
                mesh.rotation.x = -Math.PI / 2;
                
                gameGroup.add(mesh);
                modelLoaded();
            }, undefined, (error) => {
                console.error('無法載入完整骨架參考模型', error);
                modelLoaded();
            });
        }
        
        function createBones() {
            const stlLoader = new STLLoader();
            boneDefinitions.forEach(def => {
                modelsToLoad++;
                const url = def.modelUrl.replace(/ /g, '%20');
                stlLoader.load(url, (geometry) => {
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0xebe5d1,
                        metalness: 0.3,
                        roughness: 0.6
                    });
                    
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    geometry.translate(-center.x, -center.y, -center.z);

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.scale.set(def.scale, def.scale, def.scale);
                    mesh.rotation.x = -Math.PI / 2;
                    
                    setupBone(mesh, def);
                    modelLoaded();
                }, undefined, (error) => {
                    console.error(`無法載入模型: ${def.id}`, error);
                    modelLoaded();
                });
            });
        }

        function setupBone(mesh, def) {
            mesh.position.copy(def.initialPos);
            mesh.userData = { 
                id: def.id, 
                name: def.name, 
                type: 'draggable', 
                placed: false, 
                initialPos: def.initialPos.clone(),
                targetPos: def.targetPos
            };
            gameGroup.add(mesh);
            draggableObjects.push(mesh);
            bonesData.push(mesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePointerPosition(event) {
            const pointer = event.touches ? event.touches[0] : event;
            mouse.x = (pointer.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(pointer.clientY / window.innerHeight) * 2 + 1;
        }

        // --- 優化：整合桌面與觸控操作邏輯 ---
        
        function onPointerDown(event) {
            event.preventDefault(); // 防止頁面滾動等預設行為
            
            const pointer = event.touches ? event.touches[0] : event;
            pointerDownPosition.set(pointer.clientX, pointer.clientY);
            updatePointerPosition(event);
            
            // 手機/平板：設定長按計時器來觸發拖曳
            if (event.touches) {
                longPressTimeout = setTimeout(() => {
                    startDrag();
                    longPressTimeout = null;
                }, 250); // 250毫秒算作長按
            } else {
                // 電腦：立即開始拖曳檢測
                startDrag();
            }
        }
        
        function startDrag() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggableObjects, true);

            if (intersects.length > 0) {
                let object = intersects[0].object;
                while (object.parent && !object.userData.type) {
                    object = object.parent;
                }
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    selectedObject = object;
                    isDragging = true;
                    controls.enabled = false; // 拖曳時關閉視角控制

                    // 優化：建立一個與攝影機平行的平面來進行拖曳，手感更佳
                    const distance = camera.position.distanceTo(selectedObject.position);
                    dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal), selectedObject.position);
                }
            }
        }


        function onPointerMove(event) {
            if (event.touches) {
                const pointer = event.touches[0];
                // 如果手指移動超過一個微小範圍，就取消長按，視為旋轉視角
                if (longPressTimeout && pointerDownPosition.distanceTo(new THREE.Vector2(pointer.clientX, pointer.clientY)) > 10) {
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;
                }
            }
        
            updatePointerPosition(event);

            // 如果正在拖曳物件
            if (isDragging && selectedObject) {
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(dragPlane, intersectionPoint);
                selectedObject.position.copy(intersectionPoint);
                return;
            }

            // 如果只是滑鼠移動（未拖曳），則顯示骨骼名稱
            if (!isDragging) {
                 raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(draggableObjects, true);
                if (intersects.length > 0) {
                    let object = intersects[0].object;
                     while (object.parent && !object.userData.type) {
                        object = object.parent;
                    }
                    if (object.userData.name) {
                        boneNameText.textContent = object.userData.name;
                        document.body.style.cursor = 'pointer';
                    }
                } else {
                    boneNameText.textContent = '';
                    document.body.style.cursor = 'default';
                }
            }
        }

        function onPointerUp(event) {
            // 清除長按計時器
            if (longPressTimeout) {
                clearTimeout(longPressTimeout);
                longPressTimeout = null;
            }
            
            if (isDragging && selectedObject) {
                const targetPos = selectedObject.userData.targetPos;
                const distance = selectedObject.position.distanceTo(targetPos);

                if (distance < 30) { // 統一桌面和手機的吸附範圍
                    selectedObject.position.copy(targetPos);
                    selectedObject.userData.placed = true;
                    selectedObject.material.color.set(0x50c878);
                    checkCompletion();
                } else {
                    selectedObject.position.copy(selectedObject.userData.initialPos);
                }
            }

            // 重置狀態
            isDragging = false;
            selectedObject = null;
            controls.enabled = true; // 重新啟用視角控制
            document.body.style.cursor = 'default';
        }

        function checkCompletion() {
            const allPlaced = draggableObjects.every(obj => obj.userData.placed);
            if (allPlaced) {
                completionMessage.style.display = 'flex';
            }
        }

        function resetGame() {
            completionMessage.style.display = 'none';
            bonesData.forEach(bone => {
                bone.userData.placed = false;
                bone.position.copy(bone.userData.initialPos);
                bone.material.color.set(0xebe5d1);
            });
        }
        
        function animate() {
            controls.update();
            
            // VR 控制器更新
            handleController(controller1);
            handleController(controller2);
            
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
