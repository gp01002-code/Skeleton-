<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D人體骨骼拼圖 V3.0 (功能增強版)</title>
    <!-- 引入 Tailwind CSS 以進行快速樣式設計 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自訂樣式 */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c; /* 深色背景 */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 320px;
            z-index: 10; /* 確保在VR按鈕之上 */
        }
        .bone-name {
            min-height: 32px; /* 預留空間避免跳動 */
        }
        .button {
            transition: all 0.2s ease-in-out;
        }
        .button:hover {
            transform: scale(1.05);
        }
        #completion-message {
            display: none; /* 預設隱藏 */
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <!-- 讀取指示器 -->
    <div id="loading-overlay" class="absolute inset-0 z-30 flex items-center justify-center bg-black bg-opacity-70 text-white">
        <p class="text-2xl">模型載入中...</p>
    </div>

    <!-- 遊戲資訊面板 -->
    <div class="info-panel shadow-lg">
        <h1 class="text-2xl font-bold text-white">3D人體骨骼拼圖</h1>
        
        <!-- 新增：計時器 -->
        <div class="mt-4 flex justify-between items-center text-lg">
            <span class="text-gray-300">遊戲時間:</span>
            <span id="timer-text" class="font-mono text-cyan-300 text-xl">00:00</span>
        </div>

        <!-- 修改：骨骼資訊顯示區 -->
        <div id="bone-info-container" class="mt-4 p-3 bg-gray-900 bg-opacity-50 rounded-lg" style="min-height: 120px;">
             <p id="bone-name-text" class="text-xl text-cyan-300 font-semibold bone-name"></p>
             <p id="bone-description-text" class="text-gray-300 mt-1"></p>
        </div>
    </div>

    <!-- 遊戲完成訊息 -->
    <div id="completion-message" class="absolute inset-0 z-20 flex-col items-center justify-center bg-black bg-opacity-80 text-white text-center">
        <h2 class="text-6xl font-bold mb-4 animate-pulse">恭喜！</h2>
        <p class="text-2xl mb-8">您已成功拼湊出完整的人體骨骼！</p>
         <!-- 新增：顯示最終時間 -->
        <p id="final-time-text" class="text-2xl mb-8"></p>
        <button id="play-again-button" class="bg-blue-600 hover-bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl button shadow-xl">
            再玩一次
        </button>
    </div>

    <!-- 重置按鈕 -->
    <button id="reset-button" class="absolute bottom-5 right-5 bg-red-600 hover-bg-red-700 text-white font-bold py-2 px-5 rounded-lg z-10 button shadow-lg">
        重置
    </button>

    <!-- Three.js ES6 模組引入 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- 主要遊戲邏輯 -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- 變數初始化 ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let selectedObject = null;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let gameGroup;
        
        // --- 操作優化變數 ---
        const dragPlane = new THREE.Plane();
        const intersectionPoint = new THREE.Vector3();
        let longPressTimeout = null;
        let isDragging = false;
        const pointerDownPosition = new THREE.Vector2();
        const dragOffset = new THREE.Vector3();

        // --- 新增：計時器變數 ---
        let timerInterval = null;
        let secondsElapsed = 0;
        let gameStarted = false;

        const draggableObjects = [];
        const bonesData = [];
        let modelsToLoad = 0;

        // UI 元素
        const boneNameText = document.getElementById('bone-name-text');
        const boneDescriptionText = document.getElementById('bone-description-text');
        const completionMessage = document.getElementById('completion-message');
        const resetButton = document.getElementById('reset-button');
        const playAgainButton = document.getElementById('play-again-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const timerText = document.getElementById('timer-text');
        const finalTimeText = document.getElementById('final-time-text');
        
        const sceneScaleFactor = 10;
        const referencePosition = new THREE.Vector3(0, 12.5, 0); // 修正：將參考骨架稍微下移以對齊

        // --- 新增：為骨骼資料加入描述 ---
        const boneDefinitions = [
            { id: 'pelvis', name: '骨盆', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/pelvis.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, 0, 0), targetPos: new THREE.Vector3(0, 16, 0), description: '保護腹腔器官，連接脊柱與下肢的橋樑。男女骨盆形狀不同，女性的更為寬闊以利生育。' },
            { id: 'spinal_cord', name: '脊柱', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/spinal%20cord.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(0, -80, 0), targetPos: new THREE.Vector3(0, 38.5, -2), description: '由33塊椎骨組成，是支撐身體的核心。它不僅保護重要的脊髓神經，其S形曲線也提供了避震與平衡的功能。' },
            { id: 'chest', name: '胸腔', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/chest.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(0, 100, 0), targetPos: new THREE.Vector3(0, 44, 0), description: '由12對肋骨、胸骨等組成，像盔甲一樣保護心臟與肺部。呼吸時，胸腔會擴張與收縮。' },
            { id: 'skull', name: '頭骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/head.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, 50, 0), targetPos: new THREE.Vector3(0, 70.5, -1), description: '由22塊骨頭組成，其中只有下頜骨可以活動。它像安全帽一樣，保護著身體最重要的器官—大腦。' },
            { id: 'humerus_l', name: '左肱骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/upperarm02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-85, 30, 0), targetPos: new THREE.Vector3(-11, 43.5, 0), description: '上臂的單一長骨，連接肩部與肘部。它的球狀頂端與肩胛骨形成球窩關節，是人體活動範圍最大的關節。' },
            { id: 'humerus_r', name: '右肱骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/upperarm.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(85, 30, 0), targetPos: new THREE.Vector3(11, 43.5, 0), description: '上臂的單一長骨，連接肩部與肘部。它的球狀頂端與肩胛骨形成球窩關節，是人體活動範圍最大的關節。' },
            { id: 'radius_ulna_l', name: '左前臂骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/forearm02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-95, -20, 0), targetPos: new THREE.Vector3(-22, 15, 0), description: '由較粗的橈骨和較細的尺骨組成。這兩根骨頭的巧妙結構讓前臂與手腕能夠做出翻轉（旋前旋後）的動作。' },
            { id: 'radius_ulna_r', name: '右前臂骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/forearm.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(95, -20, 0), targetPos: new THREE.Vector3(22, 15, 0), description: '由較粗的橈骨和較細的尺骨組成。這兩根骨頭的巧妙結構讓前臂與手腕能夠做出翻轉（旋前旋後）的動作。' },
            { id: 'femur_l', name: '左股骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/thighbone02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, -50, 0), targetPos: new THREE.Vector3(-8, 0.5, 0), description: '人體中最長、最重、最堅固的骨骼，位於大腿。它能承受相當於體重30倍的壓力，是支撐與行走的核心。' },
            { id: 'femur_r', name: '右股骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/thighbone.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, -50, 0), targetPos: new THREE.Vector3(8, 0.5, 0), description: '人體中最長、最重、最堅固的骨骼，位於大腿。它能承受相當於體重30倍的壓力，是支撐與行走的核心。' },
            { id: 'tibia_l', name: '左脛骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/calf%20bone%2002.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, -80, 0), targetPos: new THREE.Vector3(-6, -34.5, 0), description: '小腿前側較粗的骨骼，俗稱「迎面骨」，主要負責承受體重。它與較細的腓骨共同構成小腿骨架。' },
            { id: 'tibia_r', name: '右脛骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/calf%20bone.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, -80, 0), targetPos: new THREE.Vector3(6, -34.5, 0), description: '小腿前側較粗的骨骼，俗稱「迎面骨」，主要負責承受體重。它與較細的腓骨共同構成小腿骨架。' }
        ];
        
        init();

        function init() {
            scene = new THREE.Scene();
            gameGroup = new THREE.Group();
            gameGroup.position.z = -80; 
            scene.add(gameGroup);

            // 修正：更換為更有氣氛的深色房間背景
            new THREE.TextureLoader().load(
                'https://live.staticflickr.com/65535/51694358825_31da29497d_k.jpg', // 修正：更換為一個絕對穩定的背景連結
                (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.background = texture;
                    scene.environment = texture;
                }
            );

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 220;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // 修正：配合場景調整光線，增強氣氛
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(50, 100, 75);
            scene.add(directionalLight);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.copy(referencePosition).add(gameGroup.position);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            setupVRControllers();
            loadFullSkeletonReference();
            createBones();

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
            renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: false });
            renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onPointerUp);
            
            resetButton.addEventListener('click', resetGame);
            playAgainButton.addEventListener('click', resetGame);
            
            // 初始化說明文字
            boneDescriptionText.textContent = '將骨骼拖曳到中央的正確位置。';

            renderer.setAnimationLoop(animate);
        }

        // --- 新增：計時器相關函式 ---
        function startTimer() {
            if (timerInterval) return; 
            secondsElapsed = 0;
            timerInterval = setInterval(() => {
                secondsElapsed++;
                const minutes = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
                const seconds = (secondsElapsed % 60).toString().padStart(2, '0');
                timerText.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }


        function setupVRControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            const model1 = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
            );
            model1.scale.z = 100; // 修正：將射線拉長100倍，使其在VR中可見
            controllerGrip1.add(model1);
            scene.add(controllerGrip1);

            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            scene.add(controller2);

            controllerGrip2 = renderer.xr.getControllerGrip(1);
            const model2 = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
            );
            model2.scale.z = 100; // 修正：將射線拉長100倍，使其在VR中可見
            controllerGrip2.add(model2);
            scene.add(controllerGrip2);
        }

        function onSelectStart(event) {
            const controller = event.target;
            const intersections = getIntersections(controller);

            if (intersections.length > 0) {
                let object = intersections[0].object;
                while (object.parent && !object.userData.type) { object = object.parent; }
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    if (!gameStarted) {
                        startTimer();
                        gameStarted = true;
                    }
                    selectedObject = object;
                    boneNameText.textContent = selectedObject.userData.name;
                    boneDescriptionText.textContent = selectedObject.userData.description;
                    controller.attach(selectedObject);
                }
            }
        }

        function onSelectEnd(event) {
            if (selectedObject) {
                gameGroup.attach(selectedObject);
                const targetPos = selectedObject.userData.targetPos;
                const distance = selectedObject.position.distanceTo(targetPos);
                if (distance < 40) {
                    selectedObject.position.copy(targetPos);
                    selectedObject.userData.placed = true;
                    selectedObject.material.color.set(0x50c878);
                    checkCompletion();
                } else {
                    selectedObject.position.copy(selectedObject.userData.initialPos);
                }
                selectedObject = null;
            }
        }
        
        function handleController(controller, grip) {
            if (controller.visible && grip) {
                const line = grip.getObjectByProperty('type', 'Line');
                if (!line) return; 
                const intersections = getIntersections(controller);
                if (intersections.length > 0) {
                     let object = intersections[0].object;
                     while (object.parent && !object.userData.type) { object = object.parent; }
                    if(object.userData.type === 'draggable' && !object.userData.placed){
                        line.material.color.set(0x00ff00);
                    } else {
                        line.material.color.set(0xffffff);
                    }
                } else {
                    line.material.color.set(0xffffff);
                }
            }
        }

        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            return raycaster.intersectObjects(draggableObjects, true);
        }
        
        function modelLoaded() {
            modelsToLoad--;
            if (modelsToLoad <= 0) { loadingOverlay.style.display = 'none'; }
        }

        function loadFullSkeletonReference() {
            modelsToLoad++;
            const loader = new STLLoader();
            const modelUrl = 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/untitled.stl';
            loader.load(modelUrl, (geometry) => {
                const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0.25, metalness: 0.2, roughness: 0.8 });
                geometry.computeBoundingBox();
                const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                geometry.translate(-center.x, -center.y, -center.z);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(0.35 * sceneScaleFactor, 0.35 * sceneScaleFactor, 0.35 * sceneScaleFactor);
                mesh.position.copy(referencePosition); 
                mesh.rotation.x = -Math.PI / 2;
                gameGroup.add(mesh);
                modelLoaded();
            }, undefined, (error) => {
                console.error('無法載入完整骨架參考模型', error);
                modelLoaded();
            });
        }
        
        function createBones() {
            const stlLoader = new STLLoader();
            boneDefinitions.forEach(def => {
                modelsToLoad++;
                const url = def.modelUrl.replace(/ /g, '%20');
                stlLoader.load(url, (geometry) => {
                    const material = new THREE.MeshStandardMaterial({ color: 0xebe5d1, metalness: 0.3, roughness: 0.6 });
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    geometry.translate(-center.x, -center.y, -center.z);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.scale.set(def.scale, def.scale, def.scale);
                    mesh.rotation.x = -Math.PI / 2;
                    setupBone(mesh, def);
                    modelLoaded();
                }, undefined, (error) => {
                    console.error(`無法載入模型: ${def.id}`, error);
                    modelLoaded();
                });
            });
        }

        function setupBone(mesh, def) {
            mesh.position.copy(def.initialPos);
            mesh.userData = { 
                id: def.id, name: def.name, type: 'draggable', placed: false, 
                initialPos: def.initialPos.clone(), targetPos: def.targetPos,
                description: def.description // 將描述加入 userData
            };
            gameGroup.add(mesh);
            draggableObjects.push(mesh);
            bonesData.push(mesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePointerPosition(event) {
            const pointer = event.touches ? event.touches[0] : event;
            mouse.x = (pointer.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(pointer.clientY / window.innerHeight) * 2 + 1;
        }
        
        function onPointerDown(event) {
            event.preventDefault();
            const pointer = event.touches ? event.touches[0] : event;
            pointerDownPosition.set(pointer.clientX, pointer.clientY);
            updatePointerPosition(event);
            if (event.touches) {
                longPressTimeout = setTimeout(() => { startDrag(); longPressTimeout = null; }, 250);
            } else { startDrag(); }
        }
        
        function startDrag() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggableObjects, true);
            if (intersects.length > 0) {
                let object = intersects[0].object;
                while (object.parent && !object.userData.type) { object = object.parent; }
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    if (!gameStarted) {
                        startTimer();
                        gameStarted = true;
                    }
                    selectedObject = object;
                    isDragging = true;
                    controls.enabled = false;
                    boneNameText.textContent = selectedObject.userData.name;
                    boneDescriptionText.textContent = selectedObject.userData.description;
                    dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal), intersects[0].point);
                    dragOffset.copy(intersects[0].point).sub(selectedObject.position);
                }
            }
        }

        function onPointerMove(event) {
            if (event.touches) {
                const pointer = event.touches[0];
                if (longPressTimeout && pointerDownPosition.distanceTo(new THREE.Vector2(pointer.clientX, pointer.clientY)) > 10) {
                    clearTimeout(longPressTimeout);
                    longPressTimeout = null;
                }
            }
            updatePointerPosition(event);
            if (isDragging && selectedObject) {
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(dragPlane, intersectionPoint);
                selectedObject.position.copy(intersectionPoint).sub(dragOffset);
                return;
            }
            if (!isDragging) {
                 raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(draggableObjects, true);
                if (intersects.length > 0) {
                    let object = intersects[0].object;
                     while (object.parent && !object.userData.type) { object = object.parent; }
                    if (object.userData.name) {
                        boneNameText.textContent = object.userData.name;
                        boneDescriptionText.textContent = object.userData.description;
                        document.body.style.cursor = 'pointer';
                    }
                } else {
                    boneNameText.textContent = '';
                    boneDescriptionText.textContent = '將骨骼拖曳到中央的正確位置。';
                    document.body.style.cursor = 'default';
                }
            }
        }

        function onPointerUp(event) {
            if (longPressTimeout) { clearTimeout(longPressTimeout); longPressTimeout = null; }
            if (isDragging && selectedObject) {
                const targetPos = selectedObject.userData.targetPos;
                const distance = selectedObject.position.distanceTo(targetPos);
                if (distance < 30) {
                    selectedObject.position.copy(targetPos);
                    selectedObject.userData.placed = true;
                    selectedObject.material.color.set(0x50c878);
                    checkCompletion();
                } else {
                    selectedObject.position.copy(selectedObject.userData.initialPos);
                }
            }
            isDragging = false;
            selectedObject = null;
            controls.enabled = true;
            document.body.style.cursor = 'default';
        }

        function checkCompletion() {
            const allPlaced = draggableObjects.every(obj => obj.userData.placed);
            if (allPlaced) {
                stopTimer();
                finalTimeText.textContent = `您的完成時間為：${timerText.textContent}`;
                completionMessage.style.display = 'flex';
            }
        }

        function resetGame() {
            completionMessage.style.display = 'none';
            stopTimer();
            secondsElapsed = 0;
            timerText.textContent = '00:00';
            gameStarted = false;
            bonesData.forEach(bone => {
                bone.userData.placed = false;
                bone.position.copy(bone.userData.initialPos);
                bone.material.color.set(0xebe5d1);
            });
        }
        
        function animate() {
            controls.update();
            handleController(controller1, controllerGrip1);
            handleController(controller2, controllerGrip2);
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>








