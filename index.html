<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D人體骨骼拼圖 V2.5 - 初始位置優化</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a202c;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 320px;
            z-index: 10;
        }
        .bone-name {
            min-height: 32px;
        }
        .button {
            transition: all 0.2s ease-in-out;
        }
        .button:hover {
            transform: scale(1.05);
        }
        #completion-message {
            display: none;
            transition: opacity 0.5s;
        }
        .debug-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: #00ff00;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            display: none; /* 預設隱藏，按 D 鍵顯示 */
            z-index: 11;
        }
    </style>
</head>
<body>
    <!-- 讀取指示器 -->
    <div id="loading-overlay" class="absolute inset-0 z-30 flex items-center justify-center bg-black bg-opacity-70 text-white">
        <p class="text-2xl">模型載入中...</p>
    </div>

    <!-- 遊戲資訊面板 -->
    <div id="info-panel-html" class="info-panel shadow-lg">
        <h1 class="text-2xl font-bold text-white">3D人體骨骼拼圖</h1>
        <p id="instruction-text" class="text-gray-300 mt-1">將骨骼拖曳到中央骨架的正確位置上。</p>
        <p id="bone-name-text" class="mt-3 text-xl text-cyan-300 font-semibold bone-name"></p>
        <p id="timer-text" class="mt-2 text-2xl text-yellow-300 font-mono">時間: 00:00</p>
        <p id="placed-count" class="mt-2 text-lg text-green-300">已放置: 0/12</p>
    </div>

    <!-- 遊戲完成訊息 -->
    <div id="completion-message" class="absolute inset-0 z-20 flex-col items-center justify-center bg-black bg-opacity-80 text-white text-center">
        <h2 class="text-6xl font-bold mb-4 animate-pulse">恭喜！</h2>
        <p class="text-2xl mb-8">您已成功拼湊出完整的人體骨骼！</p>
        <button id="play-again-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-xl button shadow-xl">
            再玩一次
        </button>
    </div>

    <!-- 重置按鈕 -->
    <button id="reset-button" class="absolute bottom-5 right-5 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-5 rounded-lg z-10 button shadow-lg">
        重置
    </button>
    
    <!-- Debug Panel -->
    <div id="debug-panel" class="debug-panel">
        <pre id="debug-info">Debug Info</pre>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- 變數初始化 ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let selectedObject = null;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        
        // 控制器狀態追蹤
        const controllerStates = {
            controller1: {
                intersectedObject: null,
                selectedObject: null,
                line: null
            },
            controller2: {
                intersectedObject: null,
                selectedObject: null,
                line: null
            }
        };
        
        const draggableObjects = [];
        const bonesData = [];
        let modelsToLoad = 0;
        let placedCount = 0;

        // 計時器變數
        let startTime = null;
        let timerInterval = null;
        let vrInfoPanel;
        let vrCompletionPanel;
        
        // VR 面板更新節流
        let lastVRPanelUpdate = 0;
        const VR_PANEL_UPDATE_INTERVAL = 100; // 毫秒

        // UI 元素
        const boneNameText = document.getElementById('bone-name-text');
        const timerText = document.getElementById('timer-text');
        const placedCountText = document.getElementById('placed-count');
        const completionMessage = document.getElementById('completion-message');
        const resetButton = document.getElementById('reset-button');
        const playAgainButton = document.getElementById('play-again-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const infoPanelHTML = document.getElementById('info-panel-html');
        const debugPanel = document.getElementById('debug-panel');
        const debugInfo = document.getElementById('debug-info');
        
        const sceneScaleFactor = 10;
        const referencePosition = new THREE.Vector3(0, 13.5, 0);
        const snapDistance = 25;

        const boneDefinitions = [
            { id: 'pelvis', name: '骨盆', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/pelvis.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, 0, 0), targetPos: new THREE.Vector3(0, 18, 0) },
            { id: 'spinal_cord', name: '脊柱', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/spinal%20cord.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(0, -80, 0), targetPos: new THREE.Vector3(0, 43.5, -2) },
            { id: 'chest', name: '胸腔', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/chest.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(0, 90, 0), targetPos: new THREE.Vector3(0, 44, 0) },
            { id: 'skull', name: '頭骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/head.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, 50, 0), targetPos: new THREE.Vector3(0, 70.5, -1) },
            { id: 'humerus_l', name: '左肱骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/upperarm02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-95, 30, 0), targetPos: new THREE.Vector3(-11, 43.5, -2) },
            { id: 'humerus_r', name: '右肱骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/upperarm.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(95, 30, 0), targetPos: new THREE.Vector3(11, 43.5, -2) },
            { id: 'radius_ulna_l', name: '左前臂骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/forearm02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-95, -20, 0), targetPos: new THREE.Vector3(-22, 15, 2) },
            { id: 'radius_ulna_r', name: '右前臂骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/forearm.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(95, -20, 0), targetPos: new THREE.Vector3(22, 15, 2) },
            { id: 'femur_l', name: '左股骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/thighbone02.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, -50, 0), targetPos: new THREE.Vector3(-8, 0.5, 0) },
            { id: 'femur_r', name: '右股骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/thighbone.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, -50, 0), targetPos: new THREE.Vector3(8, 0.5, 0) },
            { id: 'tibia_l', name: '左脛骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/calf%20bone%2002.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(-80, -80, 0), targetPos: new THREE.Vector3(-6, -34.5, 0) },
            { id: 'tibia_r', name: '右脛骨', modelUrl: 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/calf%20bone.stl', scale: 0.35 * sceneScaleFactor, initialPos: new THREE.Vector3(80, -80, 0), targetPos: new THREE.Vector3(6, -34.5, 0) }
        ];
        
        // Debug 模式開關
        window.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
            }
        });
        
        init();

        function init() {
            scene = new THREE.Scene();
            
            new THREE.TextureLoader().load(
                'https://live.staticflickr.com/65535/49333912182_a231368962_k.jpg',
                (texture) => {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.background = texture;
                    scene.environment = texture;
                }
            );

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 250;
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            const vrButton = VRButton.createButton(renderer);
            document.body.appendChild(vrButton);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(50, 100, 75);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 0.5);
            pointLight.position.set(0, 50, 50);
            scene.add(pointLight);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            createVRInfoPanel();
            createVRCompletionPanel();
            setupVRControllers();
            loadFullSkeletonReference();
            createBones();
            createGroundPlane();

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onPointerDown);
            renderer.domElement.addEventListener('mousemove', onPointerMove);
            renderer.domElement.addEventListener('mouseup', onPointerUp);
            renderer.domElement.addEventListener('touchstart', onPointerDown, { passive: false });
            renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onPointerUp);
            
            resetButton.addEventListener('click', resetGame);
            playAgainButton.addEventListener('click', resetGame);
            
            renderer.setAnimationLoop(animate);
            
            renderer.xr.addEventListener('sessionstart', onVRSessionStart);
            renderer.xr.addEventListener('sessionend', onVRSessionEnd);
        }

        function onVRSessionStart() {
            infoPanelHTML.style.display = 'none';
            vrInfoPanel.visible = true;
            
            const session = renderer.xr.getSession();
            if (session) {
                 session.addEventListener('inputsourceschange', () => {
                    const inputSources = session.inputSources;
                    if (inputSources.length > 0) controller1.userData.inputSource = inputSources[0];
                    if (inputSources.length > 1) controller2.userData.inputSource = inputSources[1];
                });

                session.requestReferenceSpace('local').then(refSpace => {
                    renderer.xr.setReferenceSpace(refSpace);
                });
            }
        }

        function onVRSessionEnd() {
            infoPanelHTML.style.display = 'block';
            vrInfoPanel.visible = false;
            vrCompletionPanel.visible = false;
            
            Object.keys(controllerStates).forEach(key => {
                const state = controllerStates[key];
                if (state.intersectedObject && state.intersectedObject.material) {
                    state.intersectedObject.material.emissive.set(0x000000);
                }
                state.intersectedObject = null;
                state.selectedObject = null;
            });
        }

        function createGroundPlane() {
            const geometry = new THREE.PlaneGeometry(500, 500);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x202020, 
                roughness: 0.8,
                metalness: 0.2 
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -100;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function createVRInfoPanel() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const canvasWidth = 1024;
            const canvasHeight = 512;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false
            });
            
            const geometry = new THREE.PlaneGeometry(60, 30);
            vrInfoPanel = new THREE.Mesh(geometry, material);
            
            vrInfoPanel.position.set(0, 55, -70);
            vrInfoPanel.rotation.x = -0.2;
            vrInfoPanel.renderOrder = 999;
            vrInfoPanel.visible = false;
            scene.add(vrInfoPanel);

            vrInfoPanel.userData.context = context;
            vrInfoPanel.userData.texture = texture;
            vrInfoPanel.userData.canvasWidth = canvasWidth;
            vrInfoPanel.userData.canvasHeight = canvasHeight;
            
            updateVRInfoPanel(" ", "時間: 00:00", "已放置: 0/12");
        }

        function createVRCompletionPanel() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 512;

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide,
                depthTest: false
            });
            
            const geometry = new THREE.PlaneGeometry(80, 40);
            vrCompletionPanel = new THREE.Mesh(geometry, material);
            vrCompletionPanel.position.set(0, 40, -60);
            vrCompletionPanel.renderOrder = 1000;
            vrCompletionPanel.visible = false;
            scene.add(vrCompletionPanel);

            vrCompletionPanel.userData.context = context;
            vrCompletionPanel.userData.texture = texture;
        }

        function updateVRInfoPanel(boneText, timeText, countText, force = false) {
            if (!vrInfoPanel || !renderer.xr.isPresenting) return;
            
            const now = Date.now();
            if (!force && now - lastVRPanelUpdate < VR_PANEL_UPDATE_INTERVAL) return;
            lastVRPanelUpdate = now;
            
            const context = vrInfoPanel.userData.context;
            const texture = vrInfoPanel.userData.texture;
            const width = vrInfoPanel.userData.canvasWidth;
            const height = vrInfoPanel.userData.canvasHeight;
            
            context.clearRect(0, 0, width, height);
            
            const gradient = context.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.7)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, width, height);
            
            context.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            context.lineWidth = 4;
            context.strokeRect(10, 10, width - 20, height - 20);
            
            context.fillStyle = 'white';
            context.font = 'bold 60px sans-serif';
            context.fillText('3D人體骨骼拼圖', 40, 100);
            
            context.fillStyle = '#00ffff';
            context.font = 'bold 70px sans-serif';
            context.fillText(boneText || '請選擇骨骼', 40, 220);
            
            context.fillStyle = '#ffff00';
            context.font = '60px monospace';
            context.fillText(timeText, 40, 340);
            
            context.fillStyle = '#00ff00';
            context.font = '50px sans-serif';
            context.fillText(countText, 40, 440);
            
            texture.needsUpdate = true;
        }

        function updateVRCompletionPanel(timeText) {
            if (!vrCompletionPanel) return;
            
            const context = vrCompletionPanel.userData.context;
            const texture = vrCompletionPanel.userData.texture;
            
            context.clearRect(0, 0, 1024, 512);
            context.fillStyle = 'rgba(0, 0, 0, 0.9)';
            context.fillRect(0, 0, 1024, 512);
            
            context.fillStyle = '#00ff00';
            context.font = 'bold 100px sans-serif';
            context.textAlign = 'center';
            context.fillText('恭喜完成！', 512, 200);
            
            context.fillStyle = '#ffff00';
            context.font = '60px sans-serif';
            context.fillText(timeText, 512, 320);
            
            context.fillStyle = 'white';
            context.font = '40px sans-serif';
            context.fillText('按下扳機鍵重新開始', 512, 420);
            
            context.textAlign = 'left';
            texture.needsUpdate = true;
        }

        function setupVRControllers() {
            controller1 = renderer.xr.getController(0);
            controller1.name = 'controller1';
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller1.addEventListener('squeeze', onSqueeze);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            controller2.name = 'controller2';
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('squeeze', onSqueeze);
            scene.add(controller2);

            controllerGrip1 = renderer.xr.getControllerGrip(0);
            scene.add(controllerGrip1);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            scene.add(controllerGrip2);

            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0), 
                new THREE.Vector3(0, 0, -1)
            ]);
            
            const lineMaterial1 = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const line1 = new THREE.Line(lineGeometry, lineMaterial1);
            line1.scale.z = 50;
            controller1.add(line1);
            controllerStates.controller1.line = line1;
            
            const lineMaterial2 = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const line2 = new THREE.Line(lineGeometry, lineMaterial2);
            line2.scale.z = 50;
            controller2.add(line2);
            controllerStates.controller2.line = line2;
            
            const controllerGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.1);
            const controllerMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
            
            const controllerMesh1 = new THREE.Mesh(controllerGeometry, controllerMaterial);
            controllerGrip1.add(controllerMesh1);
            
            const controllerMesh2 = new THREE.Mesh(controllerGeometry, controllerMaterial);
            controllerGrip2.add(controllerMesh2);
        }

        function onSqueeze(event) {
            if (vrCompletionPanel.visible) {
                resetGame();
            }
        }

        function vibrate(controller, intensity = 0.5, duration = 100) {
            const source = controller.userData.inputSource;
            if (source && source.gamepad && source.gamepad.hapticActuators && 
                source.gamepad.hapticActuators.length > 0) {
                source.gamepad.hapticActuators[0].pulse(intensity, duration);
            }
        }

        function onSelectStart(event) {
            if (vrCompletionPanel.visible) {
                resetGame();
                return;
            }

            if (!startTime) startTimer();
            
            const controller = event.target;
            const controllerName = controller.name;
            const state = controllerStates[controllerName];
            
            const otherControllerName = controllerName === 'controller1' ? 'controller2' : 'controller1';
            const otherState = controllerStates[otherControllerName];
            
            if (state.intersectedObject && !state.intersectedObject.userData.placed) {
                if (otherState.selectedObject !== state.intersectedObject) {
                    state.selectedObject = state.intersectedObject;
                    controller.attach(state.selectedObject);
                    
                    vibrate(controller, 0.3, 50);
                    
                    const currentTimeText = timerText.textContent;
                    updateVRInfoPanel(
                        state.selectedObject.userData.name, 
                        currentTimeText, 
                        `已放置: ${placedCount}/12`,
                        true
                    );
                }
            }
        }

        function onSelectEnd(event) {
            const controller = event.target;
            const controllerName = controller.name;
            const state = controllerStates[controllerName];
            
            if (state.selectedObject) {
                scene.attach(state.selectedObject);
                
                const targetPos = state.selectedObject.userData.targetPos;
                const distance = state.selectedObject.position.distanceTo(targetPos);
                
                if (distance < snapDistance) {
                    state.selectedObject.position.copy(targetPos);
                    state.selectedObject.userData.placed = true;
                    
                    if (state.selectedObject.material) {
                        state.selectedObject.material.color.set(0x50c878);
                        state.selectedObject.material.emissive = new THREE.Color(0x50c878);
                        state.selectedObject.material.emissiveIntensity = 0.2;
                    }
                    
                    placedCount++;
                    updatePlacedCount();
                    
                    vibrate(controller, 1.0, 200);
                    checkCompletion();
                } else {
                    state.selectedObject.position.copy(state.selectedObject.userData.initialPos);
                    vibrate(controller, 0.2, 50);
                }
                
                state.selectedObject = null;
            }
        }

        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
            
            return raycaster.intersectObjects(draggableObjects, true);
        }
        
        function modelLoaded() {
            modelsToLoad--;
            if (modelsToLoad <= 0) {
                loadingOverlay.style.display = 'none';
            }
        }

        function loadFullSkeletonReference() {
            modelsToLoad++;
            const loader = new STLLoader();
            const modelUrl = 'https://raw.githubusercontent.com/gp01002-code/Skeleton-/main/untitled.stl';
            
            loader.load(modelUrl, (geometry) => {
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.25,
                    emissive: new THREE.Color(0x00ffff),
                    emissiveIntensity: 0.1
                });

                geometry.computeBoundingBox();
                const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                
                geometry.translate(-center.x, -center.y, -center.z);
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.set(0.35 * sceneScaleFactor, 0.35 * sceneScaleFactor, 0.35 * sceneScaleFactor);
                
                mesh.position.copy(referencePosition); 
                
                mesh.rotation.x = -Math.PI / 2;
                mesh.castShadow = false;
                mesh.receiveShadow = false;
                
                scene.add(mesh);
                modelLoaded();
            }, undefined, (error) => {
                console.error('無法載入完整骨架參考模型', error);
                modelLoaded();
            });
        }
        
        function createBones() {
            const stlLoader = new STLLoader();
            
            boneDefinitions.forEach(def => {
                modelsToLoad++;
                const url = def.modelUrl.replace(/ /g, '%20');
                
                stlLoader.load(url, (geometry) => {
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0xebe5d1,
                        roughness: 0.3,
                        metalness: 0.1,
                        emissive: new THREE.Color(0x000000)
                    });
                    
                    geometry.computeBoundingBox();
                    const center = geometry.boundingBox.getCenter(new THREE.Vector3());
                    geometry.translate(-center.x, -center.y, -center.z);
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.scale.set(def.scale, def.scale, def.scale);
                    mesh.rotation.x = -Math.PI / 2;
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    setupBone(mesh, def);
                    modelLoaded();
                }, undefined, (error) => {
                    console.error(`無法載入模型: ${def.id}`, error);
                    modelLoaded();
                });
            });
        }

        function setupBone(mesh, def) {
            mesh.position.copy(def.initialPos);
            mesh.userData = { 
                id: def.id, 
                name: def.name, 
                type: 'draggable', 
                placed: false, 
                initialPos: def.initialPos.clone(),
                targetPos: def.targetPos
            };
            
            scene.add(mesh);
            draggableObjects.push(mesh);
            bonesData.push(mesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePointerPosition(event) {
            const pointer = event.touches ? event.touches[0] : event;
            mouse.x = (pointer.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(pointer.clientY / window.innerHeight) * 2 + 1;
        }

        function onPointerDown(event) {
            if (event.touches) event.preventDefault();
            if (!startTime) startTimer();
            
            updatePointerPosition(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(draggableObjects, true);

            if (intersects.length > 0) {
                let object = intersects[0].object;
                while (object.parent && !object.userData.type) {
                    object = object.parent;
                }
                
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    selectedObject = object;
                    controls.enabled = false;
                    
                    if (selectedObject.material) {
                        selectedObject.userData.originalColor = selectedObject.material.color.getHex();
                        selectedObject.material.color.set(0xffff00);
                    }
                }
            }
        }

        function onPointerMove(event) {
            if (event.touches) event.preventDefault();
            updatePointerPosition(event);

            let currentBoneName = "";
            
            if (selectedObject) {
                const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                selectedObject.position.copy(pos);
                
                const targetDist = selectedObject.position.distanceTo(selectedObject.userData.targetPos);
                if (targetDist < snapDistance * 2) {
                    currentBoneName = `${selectedObject.userData.name} (接近目標)`;
                } else {
                    currentBoneName = selectedObject.userData.name;
                }
            } else {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(draggableObjects, true);
                
                draggableObjects.forEach(obj => {
                    if (obj.material && !obj.userData.placed) {
                        obj.material.emissive.set(0x000000);
                    }
                });
                
                if (intersects.length > 0) {
                    let object = intersects[0].object;
                    while (object.parent && !object.userData.type) {
                        object = object.parent;
                    }
                    
                    if (object.userData.name && !object.userData.placed) {
                        currentBoneName = object.userData.name;
                        if (object.material) {
                            object.material.emissive.set(0xffffff);
                            object.material.emissiveIntensity = 0.1;
                        }
                    }
                }
            }
            
            boneNameText.textContent = currentBoneName;
        }

        function onPointerUp(event) {
            if (selectedObject) {
                if (selectedObject.material && selectedObject.userData.originalColor) {
                    selectedObject.material.color.setHex(selectedObject.userData.originalColor);
                    delete selectedObject.userData.originalColor;
                }
                
                const targetPos = selectedObject.userData.targetPos;
                const distance = selectedObject.position.distanceTo(targetPos);
                
                if (distance < snapDistance) {
                    selectedObject.position.copy(targetPos);
                    selectedObject.userData.placed = true;
                    
                    if (selectedObject.material) {
                        selectedObject.material.color.set(0x50c878);
                        selectedObject.material.emissive = new THREE.Color(0x50c878);
                        selectedObject.material.emissiveIntensity = 0.2;
                    }
                    
                    placedCount++;
                    updatePlacedCount();
                    checkCompletion();
                } else {
                    selectedObject.position.copy(selectedObject.userData.initialPos);
                }
            }
            
            selectedObject = null;
            controls.enabled = true;
        }

        function updatePlacedCount() {
            placedCountText.textContent = `已放置: ${placedCount}/12`;
            const currentTimeText = timerText.textContent;
            updateVRInfoPanel(
                boneNameText.textContent, 
                currentTimeText, 
                `已放置: ${placedCount}/12`,
                true
            );
        }

        function checkCompletion() {
            if (placedCount >= boneDefinitions.length) {
                stopTimer();
                completionMessage.style.display = 'flex';
                
                if (renderer.xr.isPresenting) {
                    const finalTime = timerText.textContent;
                    updateVRCompletionPanel(finalTime);
                    vrCompletionPanel.visible = true;
                    vrInfoPanel.visible = false;
                    
                    if (controller1) vibrate(controller1, 1.0, 500);
                    if (controller2) vibrate(controller2, 1.0, 500);
                }
                
                animateCompletion();
            }
        }

        function animateCompletion() {
            let glowIntensity = 0;
            let increasing = true;
            
            const glowAnimation = setInterval(() => {
                if (increasing) {
                    glowIntensity += 0.02;
                    if (glowIntensity >= 0.5) increasing = false;
                } else {
                    glowIntensity -= 0.02;
                    if (glowIntensity <= 0) {
                        clearInterval(glowAnimation);
                        return;
                    }
                }
                
                draggableObjects.forEach(obj => {
                    if (obj.material) {
                        obj.material.emissiveIntensity = glowIntensity;
                    }
                });
            }, 50);
        }

        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function resetTimer() {
            stopTimer();
            startTime = null;
            timerText.textContent = "時間: 00:00";
            updateVRInfoPanel("", "時間: 00:00", `已放置: 0/12`, true);
        }

        function updateTimerDisplay() {
            if (!startTime) return;
            
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
            const seconds = (elapsedTime % 60).toString().padStart(2, '0');
            const timeString = `時間: ${minutes}:${seconds}`;
            timerText.textContent = timeString;
            
            const currentCountText = `已放置: ${placedCount}/12`;
            updateVRInfoPanel(boneNameText.textContent, timeString, currentCountText);
        }

        function resetGame() {
            completionMessage.style.display = 'none';
            vrCompletionPanel.visible = false;
            vrInfoPanel.visible = renderer.xr.isPresenting;
            resetTimer();
            placedCount = 0;
            updatePlacedCount();
            
            Object.keys(controllerStates).forEach(key => {
                const state = controllerStates[key];
                state.intersectedObject = null;
                state.selectedObject = null;
                if (state.line && state.line.material) {
                    state.line.material.color.set(0x00ff00);
                }
            });
            
            bonesData.forEach(bone => {
                bone.userData.placed = false;
                bone.position.copy(bone.userData.initialPos);
                
                if (bone.material) {
                    bone.material.color.set(0xebe5d1);
                    bone.material.emissive.set(0x000000);
                    bone.material.emissiveIntensity = 0;
                }
            });
        }
        
        function handleController(controller, controllerName) {
            if (!controller) return;
            
            const state = controllerStates[controllerName];
            
            if (state.selectedObject) return;
            
            const intersections = getIntersections(controller);
            const line = state.line;
            
            if (intersections.length > 0) {
                let object = intersections[0].object;
                while (object.parent && !object.userData.type) {
                    object = object.parent;
                }
                
                if (object.userData.type === 'draggable' && !object.userData.placed) {
                    const otherControllerName = controllerName === 'controller1' ? 'controller2' : 'controller1';
                    const otherState = controllerStates[otherControllerName];
                    
                    if (otherState.selectedObject === object) {
                        if (state.intersectedObject && state.intersectedObject !== object) {
                            state.intersectedObject.material.emissive.set(0x000000);
                        }
                        state.intersectedObject = null;
                        if (line && line.material) line.material.color.set(0xff0000);
                    } else {
                        if (state.intersectedObject !== object) {
                            if (state.intersectedObject && state.intersectedObject.material) {
                                state.intersectedObject.material.emissive.set(0x000000);
                            }
                            state.intersectedObject = object;
                            if (object.material) {
                                object.material.emissive.set(0xffffff);
                                object.material.emissiveIntensity = 0.2;
                            }
                        }
                        if (line && line.material) line.material.color.set(0xffff00);
                    }
                } else {
                    if (state.intersectedObject) {
                        if (state.intersectedObject.material) {
                            state.intersectedObject.material.emissive.set(0x000000);
                        }
                        state.intersectedObject = null;
                    }
                    if (line && line.material) line.material.color.set(0xff0000);
                }
            } else {
                if (state.intersectedObject) {
                    if (state.intersectedObject.material) {
                        state.intersectedObject.material.emissive.set(0x000000);
                    }
                    state.intersectedObject = null;
                }
                if (line && line.material) line.material.color.set(0x00ff00);
            }
        }
        
        let lastDebugUpdate = performance.now();
        
        function updateDebugInfo(now) {
            if (!debugPanel.style.display || debugPanel.style.display === 'none') return;

            const delta = now - lastDebugUpdate;
            if (delta === 0) return;
            const fps = Math.round(1000 / delta);
            
            let debugText = `FPS: ${fps}\n`;
            debugText += `Draw Calls: ${renderer.info.render.calls}\n`;
            debugText += `Triangles: ${renderer.info.render.triangles}\n`;
            debugText += `Placed: ${placedCount}/${boneDefinitions.length}\n`;
            
            if (renderer.xr.isPresenting) {
                debugText += `VR Mode: Active\n`;
                debugText += `C1 Intersect: ${controllerStates.controller1.intersectedObject ? controllerStates.controller1.intersectedObject.userData.name : 'None'}\n`;
                debugText += `C1 Selected: ${controllerStates.controller1.selectedObject ? controllerStates.controller1.selectedObject.userData.name : 'None'}\n`;
                debugText += `C2 Intersect: ${controllerStates.controller2.intersectedObject ? controllerStates.controller2.intersectedObject.userData.name : 'None'}\n`;
                debugText += `C2 Selected: ${controllerStates.controller2.selectedObject ? controllerStates.controller2.selectedObject.userData.name : 'None'}\n`;
            } else {
                debugText += `VR Mode: Inactive\n`;
            }
            
            debugInfo.textContent = debugText;
        }
        
        function animate() {
            controls.update();
            const now = performance.now();
            
            if (renderer.xr.isPresenting) {
                handleController(controller1, 'controller1');
                handleController(controller2, 'controller2');
                
                const c1Intersected = controllerStates.controller1.intersectedObject;
                const c2Intersected = controllerStates.controller2.intersectedObject;
                let currentBoneName = '';

                if (c1Intersected && !c1Intersected.userData.placed) {
                    currentBoneName = c1Intersected.userData.name;
                } else if (c2Intersected && !c2Intersected.userData.placed) {
                     currentBoneName = c2Intersected.userData.name;
                }

                const currentTimeText = timerText.textContent;
                updateVRInfoPanel(
                    currentBoneName,
                    currentTimeText,
                    `已放置: ${placedCount}/12`
                );
            }
            
            updateDebugInfo(now);
            lastDebugUpdate = now;
            
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>



